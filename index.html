




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City Design</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background-color: #dfffd6; /* Light green background */
            color: #333;
        }
        /* Navigation Bar Styles */
        nav {
            background-color: #27ae60; /* Green background */
            padding: 10px 20px;
            text-align: center;
        }
        nav a {
            color: white;
            font-size: 18px;
            margin: 0 15px;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        nav a:hover {
            background-color: #2ecc71; /* Lighter green on hover */
        }

        /* Personal Information Section */
        .personal-info {
            background-color: #fff;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 80%;
            border-radius: 10px;
        }
        .personal-info h1 {
            color: #27ae60;
            font-size: 28px;
            margin: 0;
        }
        .personal-info p {
            font-size: 16px;
            color: #333;
            line-height: 1.6;
        }
        .personal-info a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }

        /* Center Bar and Content Section Styles */
        .center-bar {
            background-color: #fff; /* White bar */
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 80%;
            border-radius: 10px;
        }
        .center-bar h1 {
            font-size: 28px;
            color: #27ae60;
            margin: 0;
        }
        .center-bar h2 {
            font-size: 22px;
            color: #27ae60;
            margin: 5px 0 0;
        }
        .content {
            padding: 20px;
        }
        .content-section {
            margin-top: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .content-section h1 {
            font-size: 28px;
            color: #27ae60;
            margin-bottom: 10px;
        }
        .content-section h2 {
            font-size: 22px;
            color: #27ae60;
            margin-top: 0;
        }
        .content-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .content-box {
            flex: 1 1 45%;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
        }
        .content-box h2 {
            font-size: 22px;
            color: #27ae60;
            margin-bottom: 10px;
        }
        .content-box p {
            font-size: 16px;
            color: #333;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav>
        <a href="#home">Home</a>
        <a href="#course-project">Course Project Introduction</a>
        <a href="#business-cases">Business Cases</a> <!-- New navigation item -->
    </nav>

    <!-- Home Section -->
    <div id="home" class="center-bar">
        <h1>Madium</h1>
        <h2>WELCOME TO OUR TEAM PORTFOLIO ON SMART CITY PROJECT</h2>
    </div>

    <div class="content">
        <div class="content-section" id="course-introduction">
            <h1>COURSE INTRODUCTION</h1>
            <h2>What is the course about?</h2>
            <p>The Design and Analysis of Algorithms course is all about developing a deep understanding of how algorithms work, how they are designed, and how they can be optimized for efficiency.</p>
        </div>

        <div class="content-section" id="course-project">
            <h1>COURSE PROJECT INTRODUCTION</h1>
            <h2>Problem Space:</h2>
            <p>Cities are growing fast. This causes problems like crowded roads, more pollution, and not enough basic resources like water and power. We need better ways to handle these issues to make cities better for people.</p>

            <h2>White Paper Findings:</h2>
            <p><strong>Simple Tech Ideas:</strong> Street lights that save energy, apps to guide traffic, and sensors to track water use.</p>
            <p><strong>Successful Cities:</strong> Cities like Copenhagen use bikes and solar panels to save energy and reduce pollution.</p>
            <p><strong>Problems:</strong> It costs a lot to add new systems, and some people don’t trust or know how to use the technology.</p>

            <h2>City Design:</h2>
            <p>- Fix old roads, water pipes, and buildings.<br>- Add simple tools like traffic cameras and air quality sensors.<br>- Test ideas in small neighborhoods first.<br>- Make sure everyone can use the technology easily.<br>- Provide quality education.</p>

            <h2>Problem Definition:</h2>
            <p>To develop a centralized system to streamline the management of university processes.</p>

            <h2>Team Details:</h2>
            <ul>
                <li><strong>Sarvesh.biral</strong> - 213<a href="https://sarveshbiral.github.io/portfolio/" target="_blank">Portfolio</a></li>
                <li><strong>Sujay.bk</strong> - 214<a href="https://sujaybk11.github.io/portfolio.github.io/" target="_blank">Portfolio</a></li>
                <li><strong>Chetan.tadahal</strong> - 215<a href="https://chetantadahal.github.io/portfolio2/" target="_blank">Portfolio</a></li>
                <li><strong>mokshagna</strong> - 216<a href="https://mokshagnad674.github.io/Mokshagna7/" target="_blank">Portfolio</a></li>
            </ul>

            <h2>Business Cases Identified:</h2>
            <ul>
                <li><strong>Student Admission Management:</strong> Sarvesh.Biral</li>
                <li><strong>Course Scheduling:</strong> sujay.bk</li>
                <li><strong>Faculty Recruitment and Management:</strong> chetan</li>
                <li><strong>Students Performance Tracking:</strong> mokshagna</li>
                <li><strong>Parking Management:</strong> sujay & sarvesh.Biral </li>
                
            </ul> 
             <h2>Business Cases code:</h2>
            <ul>
            <li><strong>code</strong> <a href="https://docs.google.com/document/d/1vArb7hw-ws7S8JssjvRH3qqvOV3C2ADoTzvokPcAm3Y/edit?usp=sharing" target="_blank">code</a></li>

            </ul>


        </div>

        <!-- Business Cases Section -->
        <div id="business-cases" class="content-section">
            <h1>Business Cases</h1>

            <!-- Business Case 1: Student Admission Management -->
            <section>
                <h2>Student Admission Management</h2>
                <p>This business case aims to improve the process of student admissions by creating a centralized system. It streamlines the process, reduces human error, and improves the efficiency of handling student applications. This system ensures that students are admitted in a transparent and systematic way, aligning with SDG 4 (Quality Education), by facilitating equitable access to educational opportunities.</p>
                <p><strong>Target 4.3:</strong> Ensure equal access for all women and men to affordable and quality technical, vocational, and tertiary education, including university education.</p>
                <p><strong>Impact:</strong> By automating admission processes, the system reduces the complexity for both students and administrators, making it easier for students from all backgrounds to access educational institutions.</p>
            </section>

            <!-- Business Case 2: Course Scheduling -->
            <section>
                <h2>Course Scheduling</h2>
                <p>The Course Scheduling system ensures that courses are scheduled in a way that maximizes resource usage, minimizes conflicts, and aligns with student demand. This system helps maintain a balanced workload for both students and faculty while optimizing classroom availability. It supports SDG 4 (Quality Education) by ensuring all students have access to the courses they need to complete their degrees.</p>
                <p><strong>Target 4.4:</strong> By 2030, increase the number of youth and adults who have relevant skills, including technical and vocational skills, for employment, decent jobs, and entrepreneurship.</p>
                <p><strong>Impact:</strong> Effective course scheduling leads to a smoother educational experience, allowing students to access the courses they need without conflicts, and ensuring that faculty resources are utilized efficiently.</p>
            </section>

            <!-- Business Case 3: Faculty Recruitment and Management -->
            <section>
                <h2>Faculty Recruitment and Management</h2>
                <p>This system aims to automate and streamline the recruitment process for faculty members. It ensures that the best talent is hired efficiently, helping educational institutions meet their staffing needs. It aligns with SDG 8 (Decent Work and Economic Growth) by promoting fair and transparent hiring practices, leading to more stable and fulfilling employment opportunities for faculty.</p>
                <p><strong>Target 8.5:</strong> By 2030, achieve full and productive employment and decent work for all women and men, including for young people and persons with disabilities, and equal pay for work of equal value.</p>
                <p><strong>Impact:</strong> The system ensures the recruitment of qualified and experienced educators, which directly impacts the quality of education and employment in the academic sector.</p>
            </section>

            <!-- Business Case 4: Students Performance Tracking -->
            <section>
                <h2>Students Performance Tracking</h2>
                <p>Tracking student performance through automated systems enables educators to assess the learning progress of each student. By identifying struggling students early, institutions can provide targeted interventions and improve learning outcomes, directly supporting SDG 4 (Quality Education).</p>
                <p><strong>Target 4.1:</strong> Ensure that all youth and a substantial proportion of adults, both men and women, achieve literacy and numeracy.</p>
                <p><strong>Impact:</strong> This business case allows for a data-driven approach to improving student performance, enabling a more personalized educational experience.</p>
            </section>

            <!-- Business Case 5: Parking Management -->
            <section>
                <h2>Parking Management</h2>
                <p>An efficient parking management system is essential for reducing congestion, improving traffic flow, and optimizing the use of urban space. By ensuring that parking spaces are properly managed, cities can contribute to SDG 11 (Sustainable Cities and Communities) by making urban areas more accessible and less polluted.</p>
                <p><strong>Target 11.2:</strong> Provide access to safe, affordable, accessible, and sustainable transport systems for all, improving road safety, notably by expanding public transport.</p>
                <p><strong>Impact:</strong> By introducing automated parking solutions, cities can minimize congestion, reduce traffic-related emissions, and make better use of available urban space.</p>
            </section>

           
            <h3>Reflections</h3>
            <h4>1. What are the kinds of problems we see in nature? (Iteration, Recursion, Backtracking)</h4>
            <p><strong>Iteration</strong></p>
            <ul>
                <li>Traveling to college every day (repeated routine)</li>
                <li>Playing the game of chess (turn-based sequences)</li>
                <li>Preparing for an assembly (step-by-step organization)</li>
                <li>The process of learning (daily practice and effort)</li>
                <li>Resource management at a wedding (iterative allocation of resources)</li>
            </ul>
            
            <p><strong>Recursion</strong></p>
            <ul>
                <li>The tree that has been growing every day (branches resembling the whole tree structure)</li>
                <li>The growth of cauliflower vegetables (fractal patterns)</li>
                <li>Matryoshka dolls (nested structure with self-similarity)</li>
                <li>A calendar (days, weeks, and months recur in predictable patterns)</li>
            </ul>
            
            <p><strong>Backtracking</strong></p>
            <ul>
                <li>Searching for a new friend’s location (exploring different paths or strategies)</li>
                <li>Solving Sudoku (backtracking to correct mistakes)</li>
                <li>The placement of objects (optimizing arrangements by trying alternatives)</li>
            </ul>
        </section>

        <section>
            <h2>2. What is Space and Time Efficiency? Why Are They Important?</h2>
            <h3>Algorithm Efficiency and Complexity</h3>
            <p><strong>Time Efficiency:</strong> Measures the computational time required to execute an algorithm and represents the number of basic operations performed by an algorithm.</p>
            <p><strong>Space Efficiency:</strong> Measures the memory (storage) required by an algorithm, tracking how much memory is consumed by the input size and determining how much additional memory is needed to solve a problem.</p>

            <h4>Key Principles:</h4>
            <ul>
                <li>A good algorithm executes quickly and saves space in the process.</li>
                <li>We should find a balance between space and time efficiency (space and time complexity).</li>
            </ul>

            <p>In the world of computer science, to perform better, we need to write algorithms that are time-efficient and use less memory. Algorithms should be resource-optimized, solving larger problems with limited computing power, and improving user experience and system performance.</p>

            <h4>Different Classes of Problems and Orders of Growth:</h4>
            <p>Orders of growth help us understand the performance of algorithms as input size increases:</p>
            <ul>
                <li><strong>Constant Time (O(1)):</strong> Performance is independent of input size.</li>
                <li><strong>Logarithmic Time (O(log n)):</strong> Performance grows logarithmically with input size.</li>
                <li><strong>Linear Time (O(n)):</strong> Performance grows proportionally with input size.</li>
                <li><strong>Quadratic Time (O(n^2)):</strong> Performance grows with the square of the input size.</li>
                <li><strong>Exponential Time (O(2^n)):</strong> Performance doubles with each addition to the input size.</li>
            </ul>
        </section>

        <section>
            <h2>3. Takeaway from Different Design Principles from Chapter 2</h2>

            <p><strong>Decomposition:</strong> Break complex problems into smaller, manageable pieces to simplify and solve them effectively.</p>

            <p><strong>Pattern Recognition:</strong> Identify recurring patterns in problems to generalize solutions and make predictions.</p>

            <p><strong>Abstraction:</strong> Focus on essential features and ignore unnecessary details to simplify problem-solving.</p>

            <p><strong>Brave vs. Cautious Traversal:</strong>
                <ul>
                    <li><strong>DFS (Brave):</strong> Explore deeply before backtracking.</li>
                    <li><strong>BFS (Cautious):</strong> Explore level by level.</li>
                </ul>
            </p>


  <p><strong>Pruning:</strong> Skip unnecessary paths to save time and resources (e.g., N-Queen’s problem).</p>

            <p><strong>Lazy Propagation:</strong> Delay updates in data structures like segment trees for efficiency, especially with large datasets.</p>

            <p><strong>Sliding Window:</strong> Efficiently analyze overlapping sub-arrays, useful for tasks like finding maximum sums.</p>

            <p><strong>Level Order Traversal:</strong> Explore tree nodes level by level (similar to BFS).</p>

            <p><strong>Hierarchical Data:</strong> Use parent-child relationships (e.g., family trees) to organize and manage information.</p>

            <p><strong>Edge Relaxation:</strong> Update shortest paths in algorithms like Dijkstra’s by rechecking neighboring paths.</p>

            <p><strong>Balancing and Rotations:</strong> Prevent unbalanced trees in AVL and Red-Black trees to maintain efficient operations.</p>

            <p><strong>Kleene Closure:</strong> Find relationships in graphs and determine all possible connections (transitive closure).</p>

            <p><strong>Pre-Computing:</strong> Calculate and store frequently needed results in advance to save runtime (e.g., lookup tables).</p>

            <p><strong>Parental Dominance:</strong> Maintain efficiency in heaps by ensuring the root is the largest or smallest element.</p>

            <p><strong>Prefix and Suffix:</strong> Key for pattern matching and string operations in tasks like searching and bioinformatics.</p>

            <p><strong>Partitioning:</strong> Divide problems into smaller parts for recursion, widely used in sorting and searching.</p>

            <p><strong>Bit Manipulations:</strong> Use operations like AND, OR, XOR for memory-efficient algorithms (e.g., Fenwick trees).</p>

            <p><strong>Memoization:</strong> Store previous results in recursive algorithms to avoid redundant calculations.</p>

            <p><strong>Invariants:</strong> Conditions that stay constant during execution, ensuring correctness (e.g., maintaining sorted order).</p>

            <p><strong>Shortest Path Trees:</strong> Show shortest routes from a starting node, useful for navigation and network optimization.</p>
        </section>

        <section>
    <h4>4. Hierarchical data and how different tree data structures solve and optimize problems</h4>
    <table class="reflection-table">
        <thead>
            <tr>
                <th>Tree Type</th>
                <th>Best For</th>
                <th>Strength</th>
                <th>Limitation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>BST</td>
                <td>Sorted data with moderate updates</td>
                <td>Simple structure</td>
                <td>Can become unbalanced</td>
            </tr>
            <tr>
                <td>AVL Tree</td>
                <td>Frequent lookups and moderate insertions/deletions</td>
                <td>Guarantees balance</td>
                <td>Costly rotations</td>
            </tr>
            <tr>
                <td>Heap</td>
                <td>Priority-based operations</td>
                <td>Efficient min/max retrieval</td>
                <td>Not suited for general searching</td>
            </tr>
        </tbody>
    </table>
</section>


        <section>
            <h4>5. The need of array query algorithms and their implications</h4>
            <p><strong>Principles of Array Query Algorithms</strong></p>
            <ul>
                <li><strong>Divide and Conquer:</strong> Breaking queries into smaller subproblems for efficient computation.</li>
                <li><strong>Dynamic Programming:</strong> Storing intermediate results to avoid redundant calculations.</li>
                <li><strong>Optimization:</strong> Balancing preprocessing time with query time to achieve overall efficiency.</li>
            </ul>
            <p><strong>Array Query Algorithms: Overview</strong></p>
            <p><strong>Core Purpose:</strong> Array query algorithms are designed to efficiently retrieve, manipulate, or analyze information within large datasets, addressing challenges of:</p>
            <ul>
                <li>Fast information retrieval</li>
                <li>Complex data processing</li>
                <li>Minimizing computational complexity</li>
            </ul>
            <p><strong>Binary Search (Binary Index Tree):</strong></p>
            <ul>
                <li><strong>Principle:</strong> Divide and conquer strategy</li>
                <li><strong>Efficiency:</strong> O(log n)</li>
                <li><strong>Requirements:</strong> Sorted array</li>
                <li><strong>Applications:</strong> Used in large sorted databases</li>
            </ul>
            <p><strong>Sliding Window Technique:</strong></p>
            <ul>
                <li><strong>Principle:</strong> Maintain a window of elements</li>
                <li><strong>Efficiency:</strong> O(n)</li>
                <li><strong>Applications:</strong> Used in network traffic analysis and signal processing</li>
            </ul>
            <p><strong>Segment Tree:</strong></p>
            <ul>
                <li><strong>Principle:</strong> Divide array into segments</li>
                <li><strong>Efficiency:</strong> O(log n)</li>
                <li><strong>Applications:</strong> Range min/max queries</li>
            </ul>
        </section>

        <section>
            <h4>6. Trees and graphs and their traversals</h4>
            <p><strong>Differentiating Trees and Graphs:</strong></p>
            <ul>
                <li><strong>Tree:</strong> A simple structure with one main "root" and branches that don’t loop back (no cycles). It is like a family tree where each person has only one parent (except for the root). Example: A folder structure on your computer.</li>
                <li><strong>Graph:</strong> A graph is more complex. It can have cycles (loops) and no specific structure. Nodes (points) can be connected in many different ways, not necessarily hierarchically. Example: A map of cities connected by roads, where you can travel in multiple directions.</li>
            </ul>
            <p><strong>Tree Traversals (Ways to visit nodes in a tree):</strong></p>
            <ul>
                <li><strong>In-Order:</strong> Visit left side, then the node, then right side. Used for: Sorting data in binary search trees.</li>
                <li><strong>Pre-Order:</strong> Visit the node first, then the left side, and then the right side. Used for: Making a copy of the tree.</li>
                <li><strong>Post-Order:</strong> Visit the left side first, then the right side, and finally the node. Used for: Deleting nodes.</li>
                <li><strong>Level-Order (BFS):</strong> Visit nodes level by level from the root. Used for: Finding the shortest path in simple trees.</li>
            </ul>
            <p><strong>Graph Traversals (Ways to visit nodes in a graph):</strong></p>
            <ul>
                <li><strong>DFS (Depth-First Search):</strong> Start at one node, go as deep as possible, and backtrack when needed. Used for: Solving mazes, finding connected components.</li>
                <li><strong>BFS (Breadth-First Search):</strong> Visit neighbors first, then their neighbors, and so on. Used for: Finding the shortest path in simple graphs, like finding the shortest route on a map.</li>
            </ul>
            <p><strong>Applications:</strong></p>
            <ul>
                <li><strong>Tree Applications:</strong></li>
                <ul>
                    <li>File System: Organizing folders and files.</li>
                    <li>Binary Search Tree (BST): Efficiently finding data in databases.</li>
                    <li>Decision Trees: Used in making decisions, like in machine learning.</li>
                </ul>
                <li><strong>Graph Applications:</strong></li>
                <ul>
                    <li>Social Networks: Connections between people (friends, followers).</li>
                    <li>Maps/Navigation: Finding the shortest route between cities or locations.</li>
                    <li>Web Crawlers: Searching the internet by following links between websites.</li>
                </ul>
            </ul>
        </section>

        <section>
            <h4>7. Sorting and searching algorithms</h4>
            <p><strong>Sorting Algorithms:</strong> Bubble Sort, Quick Sort, Merge Sort, Heap Sort.</p>
            <p><strong>Searching Algorithms:</strong> Linear Search, Binary Search, DFS, BFS.</p>
        </section>

        <section>
            <h4>8. Importance of graph algorithms with respect to spanning trees and shortest paths</h4>
            <p>Graph algorithms such as Dijkstra's and Prim’s help find optimal paths and spanning trees in networks.</p>
        </section>

        <section>
            <h4>9. Discuss the different studied algorithm design techniques</h4>
            <p>Techniques like Brute Force, Divide and Conquer, and Greedy algorithms provide strategies for solving computational problems.</p>
        </section>
    </div>
</body>
</html>
